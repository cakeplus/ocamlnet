OCAMLNET

Optimization:
  - Uq_io.input_lines: reads as much lines as possible from in_buffer
    and returns list of lines
    -> useful in Mapred_task_exec, emap implementation

Netmulticore:
 - type heap_descr - DONE
 - *_descr for each data structure - DONE
 - heap: be more careful with GC colors
 - heap: support r/w locks
 - heap: support recursive locks for modify
 - heap: allow custom ints
 - heap: helper function self_contained
 - Netmcore_buffer.gc: remove all unreferenced mem blocks
 - Netmcore_hashtbl.gc: shrink the table as far as possible

Advanced:
 - Special form of condition variables one can poll on

Examples:
 - pipeline - DONE
 - nqueens - DONE
 - matrix
 - sort

Docs:
 - Multicore tutorial
 - Multicore memory management (background info)

Blogs:
 - Multicore announcement + test release
 - N-Queens
 - Pipeline
 - Matrix

Commerce:
 - Landing page: Multicore consulting
 - Landing page: Cluster consulting
 - Shop:
    * Whitepaper "Server architectures in Ocaml"
    * Whitepaper "Using multicore in Ocaml"
 - Sponsor wanted:
    * Netmcore_set, _map
 - Ocaml-Kurs





Fixes TODO:

- Http_fs: the http_stream_fs should also define a pipeline method

- Idea:
  Mimestring.create_mime_scanner: Support further options:
   - Enable_comments / Disable_comments -> (, ) can be part of atoms
   - Enable_qstrings / Disable_qstrings -> "" can be part of atoms
   - Enable_domaintoken / Disable_domaintoken -> [ ] can be part of atoms
  New optional arguments:
    ~profile:`Null if true, comments, qstrings, domaintokens are disabled
     except explicitly enabled
    ~profile:`Email for traditional settgins
  Also, there should be a new kind of token, Delimited, with
   - Delimited(start_char, text, end_char)
     e.g. Delimited('<', url, '>')
  Delimited needs to be configured:
   - Delimited_tokens(start_char, end_char, forbidden_chars)
     e.g. Delimited_tokens('<', '>', [' '])

  Even better idea:
   - highly configurable scanner Netscan

Netstring_pcre.replace: The replacement string follows PCRE syntax
(i.e. $& for whole match etc.)

Netnumber (in netstring): - DONE
 - defines all the numeric Rtypes - DONE
 - plus comparisons - DONE
 - submodule BE (big endian) - DONE
 - submodule LE (little endian) - DONE

Netnumber plus add, sub


***

GSSAPI:
 - define GSSAPI classes - DONE
 - wrap C impls of GSSAPI
 - SCRAM (RFC 5802) - DONE
 - ONCRPC + GSSAPI (RPCSEC_GSS) (RFC2203) - DONE
   Fix Rpc_auth_gssapi: canonicalize names before exporting - DONE
 - Add Rpc_server.is_dummy - DONE
 - Add Rpc_proxy: user_name config - DONE
 - Avoid string copying - DONE


***

- Http_fs: check what happens when a file is read but the stream is
  closed before EOF - DONE
- Http_client: Convenience still raises Http_error.
  Also define more clearly what "not successful" means for Http_protocol.
  - DONE
- Netfs: add `Dummy to all flags - DONE
- Netfs.copy and symlinks - DONE
- Netglob: check i18l patterns again - DONE
- Shell_fs: make the commands to execute configurable - sort of DONE

- complete Netfs, Netglob
  * Netfs: test - DONE
  * Netfs: maybe add copy method? - DONE
  * Netfs: rm -r is maybe "too" insecure - DONE
  * Netfs: support Win32 better - DONE (filenames)
  * Netfs BUG: In copy_into, filenames are not converted between
    encodings. - DONE

- Netfs: readlink - DONE

- unlinkat - DONE
- fchdir - DONE

- Netchannels.lift_in: if buffered=false, automatically enable the
  buffer the first time input_line is called

- Unixqueue: define no_group (do not spend time for group management)

- Option for Netfs.local_fs: enable_relative_names

***

- Uq_engines.signal_engine: should be thread-safe (signal function
  can be called from other thread)

- default_page_size statt
  let page_size = 
    try Netsys_mem.getpagesize() with _ -> 4096

- Shell: need some function for turning stdin/stdout into an in/out_obj_channel
  (only one descriptor can do this)

- Http: factor streaming access functions out

- function for parsing "host:port" strings (also with IPv6 support)

- Neturl: IPv6 support 

- Neturl: internationalized URLs
  RFC 3492

- Netfs applications:
  * HTTP - DONE
  * FTP

- continue netmulticore

- Performance: after lift_in, the input_line fn is slow

- Finishing pluggable DNS resolver
  * new iml Uq_engines.direct_socket_connector
  * Http_client
  * Telnet_client
  * raise Host_not_found if lookups fail!

$ find src -name "*.ml" | xargs grep gethostbyname
src/nethttpd/nethttpd_services.ml:	      let h = Unix.gethostbyname host in
src/smtp/netsmtp.ml:        | None -> (gethostbyname (gethostname ())).h_name
src/netclient/http_client.ml:	    let h = Unix.gethostbyname name in
src/netclient/telnet_client.ml:	      let h = syscall (fun () -> Unix.gethostbyname hostname) in
src/rpc/rpc_auth_sys.ml:		    let entry = Unix.gethostbyname hostname in
src/netplex/netplex_config.ml:					Unix.gethostbyname h in
src/equeue/uq_engines.ml:	let entry = Unix.gethostbyname name in (* may fail *)
src/equeue/uq_socks5.ml:	let entry = Unix.gethostbyname name in (* may fail *)
src/equeue/uq_resolver.ml:	let he = Unix.gethostbyname host in


- Finish FTP client

  * ftp_client_pi:

    do not expose this class anymore!

    no queueing anymore (do this in ftp_client)

    add method add_cmd_e  with engine interface
 
    ftp_state: add last_reply, cumulated_replies (for last command)

    method add_cmd_e : cmd -> ftp_state engine

    type action_e = ftp_state engine
    (replaces ftp_method)

    class ftp_client_pi: no Unix.file_descr arg. Instead have commands
    CONNECT of host*port and DISCONNECT

    command Catch_replies of (cmd * (ftp_state -> unit))
      [instead of onreply]

  * module Action: replace with engines
  * *_method: these also become engines
  * add support for PUT

  type ftp_method = context -> action_e

  ftp_client # exec_e : ftp_method -> ftp_state engine

  ftp_client # exec_e (connect_method ~host ())
  ++ (fun (_:ftp_state) -> ftp_client # exec_e (login_method ...))
  etc.

  exec_e has also queing semantics

 ftp_client # exec : calls Unixqueue.run and throws exceptions

----------------------------------------------------------------------
Plan for Ocamlnet 3
----------------------------------------------------------------------

--Still to do:

  * Netclient: better storage methods. Pass status code (or even header)
    to the `File or `Body function.

- Doc:
  * container sockets

--- Already done:

- Other
  * Go through examples. Fix programming style
      nethttpd DONE
      rpc/finder DONE


  * check Uq_engines.poll_process_engine
  * add Util.connector_of_sockaddr to Rpc_client
  * move signal_engine, rpc_engine to Ocamlnet
  * functions for creating Netplex_types.protocol and .socket_service_config
  * Rpc_util: function for printing arbitrary values
    (use: Nn_state, Transaction_error)
  * Rpc_client: ensure that first error is properly reported
    (instead of Message_lost)
  * bug sigchld_process: should check all processes (signals can be
    merged)

  * Rpc_proxy: layer on top of Rpc_client w/ automatic connection handling
  * Generate proxies
  * Rpc trace
  * Fix: `Accept_limit_length for Rpc_server. Add filters to clients, too
    (see msg by rafaelsen on ocamlnet-devel)
  * Bug Paolo Donadeo on ocamlnet-devel:
    `Redirect_response not working
  * Redesign Win32 named pipe support. Interface resembles socket API.
  * Security aspects of Win32 named pipes
  * Fully integrate named pipes into Unixqueue and Netplex
  * Limited support for anonymous pipes using helper threads
    (Netsys_win32: I/O threads; also support these whereever reasonable)
  * Support for something similar to Netsys_posix.spawn
  * Integrate win32 spawn into Shell
  * netplex: socket directory is ignored for Unix domain sockets.
    relative UD sockets should be taken relative to socket dir
  * netplex_main:
      - chdir for daemonize
  * netplex: Shut down master sockets after use.
  * netplex.fd_table: print fd table from Netlog
  * netclient: Set "Host" header also for proxy requests
  * netclient: parsing fails of URL http://host?param
  * nethtml: <body> is now an essential block
  * netcgi2, url: better magic to enfore '/' between script name and path info
  * Container-private servers. Containers may define additional RPC
    servers for local data traffic only. (-> address type "container")
  * think about page pools, for cases where too many pages are mmap'ed.
    Generalization of the free pages we manage in Netpagebuffer.
  * Netdate: support for RFC 3339 dates (see webdav_xml)
  * ocamlrpcgen: export _program variable in client interfaces
  * Rpc_netplex: config var for Rpc_server.set_timeout
  * RPC: prevent that xid's can be reused
  * new netplex admin command: netplex.connections. The detail string
    is implemented for RPC only, so far.
  * Documentation: What is supported on Win32?
  * nethttpd_services: GET /file//path?p=1
    parameters like p were not recognized when there was "//" in path
    (redirect_request bug)
  * nethttpd_services: if PATH_TRANSLATED points to a directory, omit the
    trailing slash. See also Nethtttpd_services.w32_fix_trailing_slash -
    but this is a hack
  * Nethttpd: configurable error response
  * Nethttpd: option for suppressing "broken pipe"
  * Gprof support
  * "syslog": Just calls syslog()


- object strings:
  class type string =
    object
      method length : int
      method string : string
      method memory : memory
      method blit_to_string : ...
      method blit_to_memory : ...
    end

  Use this in RPC context to avoid copying of strings as much as possible.
  Option for the user to see these objects:
  typedef _object string mystring<>;



- NetCGI cleanup
  * remove netcgi1
  * remove nethttpd-for-netcgi1, and fix types in nethttpd_for_netcgi2


- Shell_uq/Shell_sys: Drop Shell_sys.wait implementation. Replace with
  engine. The system_handler is replaced by something like
  type system_handler = {
     mutable eng_opt : engine opt;
       (* The engine. abort stops it. run runs it *)
     watch_descriptors : Unix.file_descr list -> Unix.file_descr list -> unit
       (* Set the descriptors to watch *)
  }

  * Shell for POSIX systems: fix the style how ocamlnet waits for 
    forked processes. The current solution does not work well for
    mt programs because it is undefined which thread gets the SIGCHLD.
      - ocamlnet-3.0test1 has had some issues here. These are now fixed.

  * Netplex:
      - set logger earlier (if external logger is used): Now using Netlog.

- fd leaks / double close:
  * Netlog: implements hash table with used descriptors (in debugging
    mode)
    - for each managed fd:
        - owning module
        - type
        - GC hook: pointer to a finalisable block. When this block is collected
          the fd is set to state "garbage
    - which fd's to manage: the long-living fd's


- Move new cookie implementation to Nethttp

- Faster URL encoding functions can be moved to Netencoding
  if really faster

- Bug: Netplex daemonization doesn't wait until the inner process is
  initialized (enough)

- Better Bigarray integration:
  * read/write with bigarray as buffer

----------------------------------------------------------------------
Performance improvements after Ocamlnet 3.0
----------------------------------------------------------------------

A list of possible improvements, once interfaces are stable again:

- Provide epoll/kqueue-based event_system

- Implement Netplex_semaphore with POSIX semaphores for systems
  supporting them

- Implement Netplex_sharedvar with Netshm shared memory for systems
  supporting that

- Implement Netsys_posix.spawn with posix_spawn for systems 
  supporting that

- Improve Rtypes performance

- RPC: generate direct mapping

- RPC: support relaying specially: if a server simply wants to forward
  an RPC call unchanged to a different port, there is no need to decode
  the message fully.

- RPC: server should support caching for configured procedures
  (Hmmm, unclear. Maybe we just want a server where one can intercept the
  raw messages.)

- Netshm: use blitting functions encoded in C (for int32 bigarrays)

----------------------------------------------------------------------
Implementation improvements after Ocamlnet 3.0
----------------------------------------------------------------------

- signalfd (Linux), as an efficient way of catching SIGCHLD
- eventfd (Linux), as an efficient way of waking equeue up from
  other threads

- Update Equeue_intro:
   * Throw out the chapter about async channel
   * Include a chapter about Uq_io

- Rpc_proxy: 
  * revise shared reliability caches.
  * idempotent calls: better the endpoint is immediately switched after
    the first failure

- Name_resolution_error
  use this in Uq_engines.connector.

- Configurable async name resolution (already started: Uq_resolver)
  [Maybe include netdns?]

- Cluster Message bus (netfunk)

- Improved shared memory support; RPC over shared memory
  [Depends very much on whether camlboxes can be made safer, and
   can be more easily integrated with equeue)

- Fix netplex + nethttpd + async API: netcgi cannot be used right now

- Netclient: Support for CONNECT

- Netclient: Code-cleanup

- Netclient: engine interface for HTTP

- access to good random number generator on all platforms
  (for cryptogrpahy) - DONE

- GSSAPI - DONE
- krb5 for rpc

- netplex component for monitoring:
   - ping RPC services, but also support for plugging in other protocols
   - post monitoring results to neighbors (UDP, optionally with multicasting)

- Fix ocamldoc warnings

- delegation classes for Netmime

- delegation classes for nethttpd config objects

- use bigarray I/O in more cases

- Fix Netplex_kit.start_helper_thread so that the component leaves
  `Starting state quickly

- Bug Win32 and netplex-admin -shutdown: Apparently, the sys client
  is not shut down, and the sys server keeps going because of this.
  There is a pipe_shutdown call for the sys client, but it does not seem
  to do what it is supposed to. Result is that the shutdown hangs.

- Rpc_server:
   * support suspended state
   * in suspended state, the server is no longer reading new serialized
     calls. It is still emitting responses, though.
   * Rpc_server.suspend_on [ `Always | `Num_unresponded_calls of int
                           | `Num_connections of int ]
   * extended check for validity of messages


----------------------------------------------------------------------
Further ideas
----------------------------------------------------------------------

- camlboxes:
  * safer. E.g. detect when there are pointers to camlbox messages,
    and prevent then that the message can be freed
  * generic copy function that copies messages to the normal heap
  * support for bigarrays, int32 etc. The custom_ops need to be
    put into the camlbox by the receiver process
  * more flexible memory management, e.g. support messages with
    dynamic size

- ocamlrpcgen:
   * immutable records
   ...

- input/output channels with the possibility of intercepting
  (e.g. progress bars). Also for MIME bodies

- netconversion: support UTF-8 byte order marks

- netconversion: support for character case

- netconversion: support for Unicode db (implement normalization forms)

- netbuffer: more search functions. Substring search. Maybe even globbing

- netdate: sanity checking (is the date valid)
  Optionally restrict Netdate.parse to certain patterns

  more calendar functions? Compat with calendar library?

- Nethttp.Header:
   missing: set_cookie_ct, get_set_cookie_ct

- implement cookie jar, optionally use it in http_client

- Focus RPC:
  * Rpc_server: Allow to set timeout for the server response itself
    (self-watching)
  * Annotations
  * Sandbox mode for decoding messages. In a first pass it is checked
    whether array and string sizes are all good (before allocating mem)

- Focus Win32:

  * CHECK: Call CancelIo to cancel the overlapped I/O requests when
    the pipe struct is freed?

- Focus Netplex:
  * Revisit: helper containers for multi-processing. Make it easy to
    define a template at system startup time, and to instantiate it
    later at any time

  * Message passing between containers: Containers can define a 
    message queue, and other containers can send XDR-able messages.
    Queues are referenced by a global naming scheme.

  * Revisit: Netplex + UDP

- mmap memory:
  * also support for mprotect
  * Netsys_mem support also for other protocol interpreters than RPC

- Log of deprecated functions (Netlog). Enabled by default.

- "syslog_emulation": The syslog protocol itself

- Nethttpd + SSL: This could be made working by establishing another
  file descriptor abstraction

  class type layered_socket =
  object
    method read : string -> int -> int -> int
      (* EAGAIN in the blocking case *)

    method write : string -> int -> int -> int
      (* EAGAIN in the blocking case *)

    method write_eof : unit -> unit
      (* EAGAIN in the blocking case *)

    method shutdown : unit -> unit
      (* EAGAIN in the blocking case *)

    method block : [`Read|`Write|`Write_eof|`Shutdown] list -> tmo:float -> [`Read|`Write|`Write_eof|`Shutdown] list
      (* Blocks until one of these ops becomes possible, and indicates
         which. There is no guarantee, however - if a following [read]
         or [write] ends with [EAGAIN], one has to [block] again.
      *)	

    method translate : [`Read|`Write|`Write_eof|`Shutdown] list -> [`Read|`Write] list
      (* Translates a high-level I/O condition to a descriptor-level r/w
         condition. The argument says what the user waits upon: read
         and/or write. The return value says how to watch the file descriptor.
         The return value may depend on the internal state of the protocol
         engine.

         For non-blocking I/O, one should first translate the user
         request, wait until the fd is in one of the indicated states,
         then call read/write. If this results in [EAGAIN], the whole
         sequence is to be repeated.
       *)

    method fd : Unix.file_descr
    method inactivate : unit -> unit
  end

- SSL support for Http_client

- Finish Ftp_client
  * rewrite problematic parts in engines style

- Netplex + RPC + SSL: should be easy to configure

- Better integration of SOCKS

- Netplex documentation:
   * netplex-admin
   * configuration manual

- more engine-style interfaces:
   * Http_client.pipeline: add requests via an engine

- support for CPS transformations

- pluggable filesystem classes - DONE

- async local file I/O

----------------------------------------------------------------------
Old stuff, check first
----------------------------------------------------------------------

Equeue:
	- Fix command engines as commented in the code.

netcgi2-plex:
	- Implement mount_dir/mount_at
	  Sched: 2.3

Bugs Tidalwave:
  * ocamlnet
	- Bug: Netstring_pcre.global_replace
	  Sched: after 2.2.0 is out

Http_client.pipeline:
	- aggressive caching does not work properly. Sometimes descriptors
	  are closed in the wrong moment. - DONE

