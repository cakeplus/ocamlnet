NEXT RELEASE:

- fix source code header for all new files
- Netfs.copy and symlinks
- Http_fs: check what happens when a file is read but the stream is
  closed before EOF

***

- Uq_engines.signal_engine: should be thread-safe (signal function
  can be called from other thread)

- complete Netfs, Netglob
  * Netfs: test - DONE
  * Netfs: maybe add copy method? - DONE
  * Netfs: rm -r is maybe "too" insecure - DONE
  * Netfs: support Win32 better - DONE (filenames)
  * Netfs BUG: In copy_into, filenames are not converted between
    encodings. - DONE

- Netfs: readlink - DONE

- unlinkat - DONE
- fchdir - DONE

- function for parsing "host:port" strings (also with IPv6 support)

- Neturl: IPv6 support 

- Neturl: internationalized URLs
  RFC 3492

- Netfs applications:
  * HTTP
  * FTP

- continue netmulticore

- Performance: after lift_in, the input_line fn is slow

- Finishing pluggable DNS resolver
  * new iml Uq_engines.direct_socket_connector
  * Http_client
  * Telnet_client

$ find src -name "*.ml" | xargs grep gethostbyname
src/nethttpd/nethttpd_services.ml:	      let h = Unix.gethostbyname host in
src/smtp/netsmtp.ml:        | None -> (gethostbyname (gethostname ())).h_name
src/netclient/http_client.ml:	    let h = Unix.gethostbyname name in
src/netclient/telnet_client.ml:	      let h = syscall (fun () -> Unix.gethostbyname hostname) in
src/rpc/rpc_auth_sys.ml:		    let entry = Unix.gethostbyname hostname in
src/netplex/netplex_config.ml:					Unix.gethostbyname h in
src/equeue/uq_engines.ml:	let entry = Unix.gethostbyname name in (* may fail *)
src/equeue/uq_socks5.ml:	let entry = Unix.gethostbyname name in (* may fail *)
src/equeue/uq_resolver.ml:	let he = Unix.gethostbyname host in


- Finish FTP client

  * ftp_client_pi:

    do not expose this class anymore!

    no queueing anymore (do this in ftp_client)

    add method add_cmd_e  with engine interface
 
    ftp_state: add last_reply, cumulated_replies (for last command)

    method add_cmd_e : cmd -> ftp_state engine

    type action_e = ftp_state engine
    (replaces ftp_method)

    class ftp_client_pi: no Unix.file_descr arg. Instead have commands
    CONNECT of host*port and DISCONNECT

    command Catch_replies of (cmd * (ftp_state -> unit))
      [instead of onreply]

  * module Action: replace with engines
  * *_method: these also become engines
  * add support for PUT

  type ftp_method = context -> action_e

  ftp_client # exec_e : ftp_method -> ftp_state engine

  ftp_client # exec_e (connect_method ~host ())
  ++ (fun (_:ftp_state) -> ftp_client # exec_e (login_method ...))
  etc.

  exec_e has also queing semantics

 ftp_client # exec : calls Unixqueue.run and throws exceptions

----------------------------------------------------------------------
Plan for Ocamlnet 3
----------------------------------------------------------------------

--Still to do:

  * Netclient: better storage methods. Pass status code (or even header)
    to the `File or `Body function.

- Doc:
  * container sockets

--- Already done:

- Other
  * Go through examples. Fix programming style
      nethttpd DONE
      rpc/finder DONE


  * check Uq_engines.poll_process_engine
  * add Util.connector_of_sockaddr to Rpc_client
  * move signal_engine, rpc_engine to Ocamlnet
  * functions for creating Netplex_types.protocol and .socket_service_config
  * Rpc_util: function for printing arbitrary values
    (use: Nn_state, Transaction_error)
  * Rpc_client: ensure that first error is properly reported
    (instead of Message_lost)
  * bug sigchld_process: should check all processes (signals can be
    merged)

  * Rpc_proxy: layer on top of Rpc_client w/ automatic connection handling
  * Generate proxies
  * Rpc trace
  * Fix: `Accept_limit_length for Rpc_server. Add filters to clients, too
    (see msg by rafaelsen on ocamlnet-devel)
  * Bug Paolo Donadeo on ocamlnet-devel:
    `Redirect_response not working
  * Redesign Win32 named pipe support. Interface resembles socket API.
  * Security aspects of Win32 named pipes
  * Fully integrate named pipes into Unixqueue and Netplex
  * Limited support for anonymous pipes using helper threads
    (Netsys_win32: I/O threads; also support these whereever reasonable)
  * Support for something similar to Netsys_posix.spawn
  * Integrate win32 spawn into Shell
  * netplex: socket directory is ignored for Unix domain sockets.
    relative UD sockets should be taken relative to socket dir
  * netplex_main:
      - chdir for daemonize
  * netplex: Shut down master sockets after use.
  * netplex.fd_table: print fd table from Netlog
  * netclient: Set "Host" header also for proxy requests
  * netclient: parsing fails of URL http://host?param
  * nethtml: <body> is now an essential block
  * netcgi2, url: better magic to enfore '/' between script name and path info
  * Container-private servers. Containers may define additional RPC
    servers for local data traffic only. (-> address type "container")
  * think about page pools, for cases where too many pages are mmap'ed.
    Generalization of the free pages we manage in Netpagebuffer.
  * Netdate: support for RFC 3339 dates (see webdav_xml)
  * ocamlrpcgen: export _program variable in client interfaces
  * Rpc_netplex: config var for Rpc_server.set_timeout
  * RPC: prevent that xid's can be reused
  * new netplex admin command: netplex.connections. The detail string
    is implemented for RPC only, so far.
  * Documentation: What is supported on Win32?
  * nethttpd_services: GET /file//path?p=1
    parameters like p were not recognized when there was "//" in path
    (redirect_request bug)
  * nethttpd_services: if PATH_TRANSLATED points to a directory, omit the
    trailing slash. See also Nethtttpd_services.w32_fix_trailing_slash -
    but this is a hack
  * Nethttpd: configurable error response
  * Nethttpd: option for suppressing "broken pipe"
  * Gprof support
  * "syslog": Just calls syslog()


- object strings:
  class type string =
    object
      method length : int
      method string : string
      method memory : memory
      method blit_to_string : ...
      method blit_to_memory : ...
    end

  Use this in RPC context to avoid copying of strings as much as possible.
  Option for the user to see these objects:
  typedef _object string mystring<>;



- NetCGI cleanup
  * remove netcgi1
  * remove nethttpd-for-netcgi1, and fix types in nethttpd_for_netcgi2


- Shell_uq/Shell_sys: Drop Shell_sys.wait implementation. Replace with
  engine. The system_handler is replaced by something like
  type system_handler = {
     mutable eng_opt : engine opt;
       (* The engine. abort stops it. run runs it *)
     watch_descriptors : Unix.file_descr list -> Unix.file_descr list -> unit
       (* Set the descriptors to watch *)
  }

  * Shell for POSIX systems: fix the style how ocamlnet waits for 
    forked processes. The current solution does not work well for
    mt programs because it is undefined which thread gets the SIGCHLD.
      - ocamlnet-3.0test1 has had some issues here. These are now fixed.

  * Netplex:
      - set logger earlier (if external logger is used): Now using Netlog.

- fd leaks / double close:
  * Netlog: implements hash table with used descriptors (in debugging
    mode)
    - for each managed fd:
        - owning module
        - type
        - GC hook: pointer to a finalisable block. When this block is collected
          the fd is set to state "garbage
    - which fd's to manage: the long-living fd's


- Move new cookie implementation to Nethttp

- Faster URL encoding functions can be moved to Netencoding
  if really faster

- Bug: Netplex daemonization doesn't wait until the inner process is
  initialized (enough)

- Better Bigarray integration:
  * read/write with bigarray as buffer

----------------------------------------------------------------------
Performance improvements after Ocamlnet 3.0
----------------------------------------------------------------------

A list of possible improvements, once interfaces are stable again:

- Provide epoll/kqueue-based event_system

- Implement Netplex_semaphore with POSIX semaphores for systems
  supporting them

- Implement Netplex_sharedvar with Netshm shared memory for systems
  supporting that

- Implement Netsys_posix.spawn with posix_spawn for systems 
  supporting that

- Improve Rtypes performance

- RPC: generate direct mapping

- RPC: support relaying specially: if a server simply wants to forward
  an RPC call unchanged to a different port, there is no need to decode
  the message fully.

- RPC: server should support caching for configured procedures
  (Hmmm, unclear. Maybe we just want a server where one can intercept the
  raw messages.)

- Netshm: use blitting functions encoded in C (for int32 bigarrays)

----------------------------------------------------------------------
Implementation improvements after Ocamlnet 3.0
----------------------------------------------------------------------

- signalfd (Linux), as an efficient way of catching SIGCHLD
- eventfd (Linux), as an efficient way of waking equeue up from
  other threads

- Update Equeue_intro:
   * Throw out the chapter about async channel
   * Include a chapter about Uq_io

- Rpc_proxy: 
  * revise shared reliability caches.
  * idempotent calls: better the endpoint is immediately switched after
    the first failure

- Name_resolution_error
  use this in Uq_engines.connector.

- Configurable async name resolution (already started: Uq_resolver)
  [Maybe include netdns?]

- Cluster Message bus (netfunk)

- Improved shared memory support; RPC over shared memory
  [Depends very much on whether camlboxes can be made safer, and
   can be more easily integrated with equeue)

- Fix netplex + nethttpd + async API: netcgi cannot be used right now

- Netclient: Support for CONNECT

- Netclient: Code-cleanup

- Netclient: engine interface for HTTP

- access to good random number generator on all platforms
  (for cryptogrpahy)

- CHECK: GSSAPI, krb5 for rpc

- netplex component for monitoring:
   - ping RPC services, but also support for plugging in other protocols
   - post monitoring results to neighbors (UDP, optionally with multicasting)

- Fix ocamldoc warnings

- delegation classes for Netmime

- delegation classes for nethttpd config objects

- use bigarray I/O in more cases

- Fix Netplex_kit.start_helper_thread so that the component leaves
  `Starting state quickly

- Bug Win32 and netplex-admin -shutdown: Apparently, the sys client
  is not shut down, and the sys server keeps going because of this.
  There is a pipe_shutdown call for the sys client, but it does not seem
  to do what it is supposed to. Result is that the shutdown hangs.

- Rpc_server:
   * support suspended state
   * in suspended state, the server is no longer reading new serialized
     calls. It is still emitting responses, though.
   * Rpc_server.suspend_on [ `Always | `Num_unresponded_calls of int
                           | `Num_connections of int ]
   * extended check for validity of messages


----------------------------------------------------------------------
Further ideas
----------------------------------------------------------------------

- camlboxes:
  * safer. E.g. detect when there are pointers to camlbox messages,
    and prevent then that the message can be freed
  * generic copy function that copies messages to the normal heap
  * support for bigarrays, int32 etc. The custom_ops need to be
    put into the camlbox by the receiver process
  * more flexible memory management, e.g. support messages with
    dynamic size

- ocamlrpcgen:
   * immutable records
   ...

- input/output channels with the possibility of intercepting
  (e.g. progress bars). Also for MIME bodies

- netconversion: support UTF-8 byte order marks

- netconversion: support for character case

- netbuffer: more search functions. Substring search. Maybe even globbing

- netdate: sanity checking (is the date valid)
  Optionally restrict Netdate.parse to certain patterns

  more calendar functions? Compat with calendar library?

- Nethttp.Header:
   missing: set_cookie_ct, get_set_cookie_ct

- implement cookie jar, optionally use it in http_client

- Focus RPC:
  * Rpc_server: Allow to set timeout for the server response itself
    (self-watching)
  * Annotations
  * Sandbox mode for decoding messages. In a first pass it is checked
    whether array and string sizes are all good (before allocating mem)

- Focus Win32:

  * CHECK: Call CancelIo to cancel the overlapped I/O requests when
    the pipe struct is freed?

- Focus Netplex:
  * Revisit: helper containers for multi-processing. Make it easy to
    define a template at system startup time, and to instantiate it
    later at any time

  * Message passing between containers: Containers can define a 
    message queue, and other containers can send XDR-able messages.
    Queues are referenced by a global naming scheme.

  * Revisit: Netplex + UDP

- mmap memory:
  * also support for mprotect
  * Netsys_mem support also for other protocol interpreters than RPC

- Log of deprecated functions (Netlog). Enabled by default.

- "syslog_emulation": The syslog protocol itself

- Nethttpd + SSL: This could be made working by establishing another
  file descriptor abstraction

  class type layered_socket =
  object
    method read : string -> int -> int -> int
      (* EAGAIN in the blocking case *)

    method write : string -> int -> int -> int
      (* EAGAIN in the blocking case *)

    method write_eof : unit -> unit
      (* EAGAIN in the blocking case *)

    method shutdown : unit -> unit
      (* EAGAIN in the blocking case *)

    method block : [`Read|`Write|`Write_eof|`Shutdown] list -> tmo:float -> [`Read|`Write|`Write_eof|`Shutdown] list
      (* Blocks until one of these ops becomes possible, and indicates
         which. There is no guarantee, however - if a following [read]
         or [write] ends with [EAGAIN], one has to [block] again.
      *)	

    method translate : [`Read|`Write|`Write_eof|`Shutdown] list -> [`Read|`Write] list
      (* Translates a high-level I/O condition to a descriptor-level r/w
         condition. The argument says what the user waits upon: read
         and/or write. The return value says how to watch the file descriptor.
         The return value may depend on the internal state of the protocol
         engine.

         For non-blocking I/O, one should first translate the user
         request, wait until the fd is in one of the indicated states,
         then call read/write. If this results in [EAGAIN], the whole
         sequence is to be repeated.
       *)

    method fd : Unix.file_descr
    method inactivate : unit -> unit
  end

- SSL support for Http_client

- Finish Ftp_client
  * rewrite problematic parts in engines style

- Netplex + RPC + SSL: should be easy to configure

- Better integration of SOCKS

- Netplex documentation:
   * netplex-admin
   * configuration manual

- more engine-style interfaces:
   * Http_client.pipeline: add requests via an engine

- support for CPS transformations

- pluggable filesystem classes

- async local file I/O

----------------------------------------------------------------------
Old stuff, check first
----------------------------------------------------------------------

Equeue:
	- Fix command engines as commented in the code.

netcgi2-plex:
	- Implement mount_dir/mount_at
	  Sched: 2.3

Bugs Tidalwave:
  * ocamlnet
	- Bug: Netstring_pcre.global_replace
	  Sched: after 2.2.0 is out

Http_client.pipeline:
	- aggressive caching does not work properly. Sometimes descriptors
	  are closed in the wrong moment.
	  Sched: 2.3
